import {
  assert,
  Field,
  FragmentElement,
  InterfaceType,
  NamedType,
  OperationElement,
  Schema,
  SchemaRootKind,
  SelectionSet,
  typenameFieldName,
  isLeafType,
  baseType,
  CompositeType,
  isAbstractType,
  newDebugLogger,
  externalDirectiveName,
  isCompositeType,
  federationBuiltIns,
  parseFieldSetArgument,
  keyDirectiveName,
  providesDirectiveName,
  possibleRuntimeTypes,
  ObjectType,
  isObjectType,
  mapValues,
} from "@apollo/core";
import { OpPathTree, traversePathTree } from "./pathTree";
import { Vertex, QueryGraph, Edge, RootVertex, isRootVertex, isFederatedGraphRootType, QueryGraphState } from "./querygraph";
import { Transition } from "./transition";
import { PathContext, emptyContext } from "./pathContext";

const debug = newDebugLogger('path');

function updateRuntimeTypes(currentRuntimeTypes: readonly ObjectType[], edge: Edge | null): readonly ObjectType[] {
  if (!edge) {
    return currentRuntimeTypes;
  }

  switch (edge.transition.kind) {
    case 'FieldCollection':
      const field = edge.transition.definition;
      if (!isCompositeType(baseType(field.type!))) {
        return [];
      }
      const newRuntimeTypes: ObjectType[] = [];
      for (const parentType of currentRuntimeTypes) {
        const fieldType = parentType.field(field.name)?.type;
        if (fieldType) {
          for (const type of possibleRuntimeTypes(baseType(fieldType) as CompositeType)) {
            if (!newRuntimeTypes.includes(type)) {
              newRuntimeTypes.push(type);
            }
          }
        }
      }
      return newRuntimeTypes;
    case 'DownCast':
      const castedType = edge.transition.castedType;
      const castedRuntimeTypes = possibleRuntimeTypes(castedType);
      return currentRuntimeTypes.filter(t => castedRuntimeTypes.includes(t));
    case 'KeyResolution':
      const currentType = edge.tail.type as CompositeType;
      // We've taken a key into a new subgraph, so any of the possible runtime types of the new subgraph could be returned.
      return possibleRuntimeTypes(currentType);
    case 'QueryResolution':
    case 'SubgraphEnteringTransition':
      assert(isObjectType(edge.tail.type), () => `Query edge should be between object type but got ${edge}`);
      return [ edge.tail.type ];
  }
}

function withReplacedLastElement<T>(arr: readonly T[], newLast: T): T[] {
  assert(arr.length > 0, 'Should not have been called on empty array');
  const newArr = new Array<T>(arr.length);
  for (let i = 0; i < arr.length - 1; i++) {
    newArr[i] = arr[i];
  }
  newArr[arr.length - 1] = newLast;
  return newArr;
}

/**
 * An immutable path in a query graph.
 *
 * Path is mostly understood in the graph theoretical sense of the term, that is as "a connnected series of edges"
 * and a `GraphPath` is generated by traversing a graph query.
 * However, as query graph edges may have conditions, a `GraphPath` also records, for reach edges it is composed of,
 * the set of paths (an `OpPathTree` in practice) that were taken to fullfill the edge conditions (when the edge has
 * one).
 *
 * Additionally, for each edge of the path, a `GraphPath` records the "trigger" that made the traversal take that
 * edge. In practice, the "trigger" can be seen as a way to decorate a path with some additional metadata for each
 * elements of the path. In practice, that trigger is used in 2 main ways (corresponding to our 2 main query graph
 * traversals):
 *  - for composition validation, the traversal of the federated query graph is driven by other transitions into the
 *    supergraph API query graphs (essentially, composition validation is aboud finding, for every supergraph API
 *    query graph path, a "matching" traversal of the federated query graph). In that case, for the graph paths
 *    we build on the federated query graph, the "trigger" will be one of the `Transition` from the supergraph
 *    API graph (which, granted, will be fairly similar to the one of the edge we're taking in the federated query
 *    graph; in practice, triggers are more useful in the query planning case).
 *  - for query planning, the traversal of the federated query graph is driven by the elements of the query we are
 *    planning. Which means that the "trigger" for taking an edge in this case will be an `OperationElement`
 *    (or null). See the specialized `OpGraphPath` that is defined for this use case.
 *
 * Lastly, some `GraphPath` can actually encode "null" edges: this is used during query planning in the (rare)
 * case where the query we plan for has fragment spread without type condition (or a "useless" one, on that doesn't
 * restrict the possible types anymore than they already were) but with some directives. In that case, we want
 * to preserve the information about the directive (to properly rebuild query plans later) but it doesn't correspond
 * to taking any edges, so we add a "null" edge and use the trigger to store the fragment spread.
 *
 * @param TTrigger - the type of the paths "triggers", metadata that can associated to each element of the path (see
 *   above for more details).
 * @param RV - the type of the vertex starting the path. This simply default to `Vertex` but is used in `RootPath`/`OpRootPath`
 *   to easily distinguish those paths that starts from a root of a query graph.
 * @param TNullEdge - typing information to indicate whether the path can have "null" edges or not. Either `null` (
 *   meaning that the path may have null edges) or `never` (the path cannot have null edges).
 */
export class GraphPath<TTrigger, RV extends Vertex = Vertex, TNullEdge extends null | never = never> {
  private constructor(
    /** The query graph of which this is a path. */
    readonly graph: QueryGraph,
    /** The vertex at which the path starts (the head vertex of the first edge in path, aliased here for convenience). */
    readonly root: RV,
    /** The vertex at which the path stops (the tail vertex of the last edge in path, aliased here for convenience). */
    readonly tail: Vertex,
    /** The triggers associated to each edges in the paths (see `GraphPath` for more details on triggers). */
    private readonly edgeTriggers: readonly TTrigger[],
    /** The edges (stored by edge index) composing the path. */
    private readonly edgeIndexes: readonly (number | TNullEdge)[],
    /**
     * For each edge in the path, if the edge has conditions, the set of paths that fullfill that condition.
     * Note that no matter which kind of traversal we are doing, fullfilling the conditions is always driven by
     * the conditions themselves, and as conditions are a graphQL result set, the resulting set of paths are
     * `OpGraphPath` (and as they are all rooted at the edge head vertex, we use the `OpPathTree` representation
     * for that set of paths).
     */
    private readonly edgeConditions: readonly (OpPathTree | null)[],

    private readonly edgeToTail: Edge | TNullEdge | undefined,
    /** Names of the all the possible runtime types the tail of the path can be. */
    private readonly runtimeTypesOfTail: readonly ObjectType[],
    /** If the last edge, the one getting to tail, was a DownCast, the runtime types before that edge. */
    private readonly runtimeTypesBeforeTailIfLastIsCast?: readonly ObjectType[],
  ) {
  }

  /**
   * Creates a new (empty) path starting at the provided vertex.
   */
  static create<TTrigger, RV extends Vertex = Vertex, TNullEdge extends null | never = never>(
    graph: QueryGraph,
    root: RV
  ): GraphPath<TTrigger, RV, TNullEdge> {
    // If 'graph' is a federated query graph, federation renames all root type to their default names, so we rely on this here.
    const runtimeTypes = isFederatedGraphRootType(root.type) ? [] : possibleRuntimeTypes(root.type as CompositeType);
    return new GraphPath(graph, root, root, [], [], [], undefined, runtimeTypes);
  }

  /**
   * Creates a new (empty) path starting from the root vertex in `graph` corresponding to the provide `rootKind`.
   */
  static fromGraphRoot<TTrigger, TNullEdge extends null | never = never>(
    graph: QueryGraph,
    rootKind: SchemaRootKind
  ): RootPath<TTrigger, TNullEdge> | undefined {
    const root = graph.root(rootKind);
    return root ? this.create(graph, root) : undefined;
  }

  /**
   * The size of the path, that is the number of edges composing it.
   *
   * Note that this only the "main" edges composing the path: some of those edges may have conditions for which the
   * path will also store the "sub-paths" necessary to fullfill said conditions, but the edges of those sub-paths are
   * _not_ counted here.
   */
  get size(): number {
    return this.edgeIndexes.length;
  }

  /**
   * The elements of the path, that is its edges accompagnied by the edge trigger and potential conditions paths.
   */
  *elements(): Generator<[Edge | TNullEdge, TTrigger, OpPathTree | null], void, undefined> {
    let vertex: Vertex = this.root;
    for (let i = 0; i < this.size; i++) {
      const edge = this.edgeAt(i, vertex);
      yield [edge, this.edgeTriggers[i], this.edgeConditions[i]];
      if (edge) {
        vertex = edge.tail;
      }
    }
  }

  /**
   * The last edge in the path (if it isn't empty).
   */
  lastEdge(): Edge | TNullEdge | undefined {
    return this.edgeToTail;
  }

  lastTrigger(): TTrigger | undefined {
    return this.edgeTriggers[this.size - 1];
  }

  tailPossibleRuntimeTypes(): readonly ObjectType[] {
    return this.runtimeTypesOfTail;
  }

  /**
   * Creates the new path corresponding to appending to this path the provided `edge`.
   *
   * @param trigger - the trigger for taking the edge in the created path.
   * @param edge - the edge to add (which may be 'null' if this type of path allows it, but if it isn't should be an out-edge
   *   for `s.tail`).
   * @param conditions - Paths necessary to fullfill `edge` conditions, if `edge` has conditions. Note that this is optional, both
   *   because not all edges have conditions, but also because we allow building a path that don't callect it's condition paths.
   *   This is the case during composition validation for instance, where we do validate that the condition can be fullfill, but
   *   don't bother collecting the corresponding paths as it is not used later).
   * @returns the newly created path.
   */
  add(trigger: TTrigger, edge: Edge | TNullEdge, conditions?: OpPathTree): GraphPath<TTrigger, RV, TNullEdge> {
    assert(!edge || this.tail.index === edge.head.index, () => `Cannot add edge ${edge} to path ending at ${this.tail}`);
    assert(!edge || edge.conditions || !conditions, () => `Shouldn't have conditions paths (got ${conditions}) for edge without conditions (edge: ${edge})`);

    if (edge && edge.transition.kind === 'DownCast' && this.edgeToTail) {
      const previousOperation = this.lastTrigger();
      if (previousOperation instanceof FragmentElement && previousOperation.appliedDirectives.length === 0) {
        // This mean we have 2 type-cast back-to-back and that means the previous operation might not be
        // useful on this path. More precisely, the previous type-cast was only useful if it restricted
        // the possible runtime types of the type on which it applied more than the current type-cast
        // does (but note that if the previous type-cast had directives, we keep it not matter what in
        // case those directives are important).
        // That is, we're in the where we have (somewhere potentially deep in a query):
        //   f {  # field 'f' of type A
        //     ... on B {
        //       ... on C {
        //          # more stuffs
        //       }
        //     }
        //   }
        // If the intersection of A and C is non empty and included (or equal) to the intersection of A and B, 
        // then there is no reason to have `... on B` at all because:
        //  1. you can do `... on C` on `f` directly since the intersection of A and C is non-empty.
        //  2. `... on C` restricts strictly more than `... on B` and so the latter can't impact the result.
        // So if we detect that we're in that situation, we remove the `... on B` (but note that this is an
        // optimization, keeping `... on B` wouldn't be incorrect, just useless).
        const runtimeTypesWithoutPreviousCast = updateRuntimeTypes(this.runtimeTypesBeforeTailIfLastIsCast!, edge);
        if (runtimeTypesWithoutPreviousCast.length > 0 
          && runtimeTypesWithoutPreviousCast.every(t => this.runtimeTypesOfTail.includes(t))
        ) {
          // Note that edge is from the vertex we've eliminating from the path. So we need to get the edge goes
          // directly from the prior vertex to the new tail for that path.
          const updatedEdge = this.graph.outEdges(this.edgeToTail!.head).find(e => e.tail.type === edge.tail.type);
          if (updatedEdge) {
            // We replace the previous operation by the new one.
            debug.log(() => `Previous cast ${previousOperation} is made obsolete by new cast ${trigger}, removing from path.`);
            return new GraphPath(
              this.graph,
              this.root,
              updatedEdge.tail,
              withReplacedLastElement(this.edgeTriggers, trigger),
              withReplacedLastElement(this.edgeIndexes, updatedEdge.index),
              withReplacedLastElement(this.edgeConditions, conditions ?? null),
              updatedEdge,
              runtimeTypesWithoutPreviousCast,
              this.runtimeTypesBeforeTailIfLastIsCast // Note that those haven't changed, and last is still a cast
            );
          }
        }
      }
    }

    return new GraphPath(
      this.graph,
      this.root,
      edge ? edge.tail : this.tail,
      this.edgeTriggers.concat(trigger),
      this.edgeIndexes.concat((edge ? edge.index : null) as number | TNullEdge),
      this.edgeConditions.concat(conditions ?? null),
      edge,
      updateRuntimeTypes(this.runtimeTypesOfTail, edge),
      edge?.transition?.kind === 'DownCast' ? this.runtimeTypesOfTail : undefined
    );
  }


  /**
   * Creates a new path corresponding to concatenating the provide path _after_ this path.
   *
   * @param tailPath - the path to concatenate at the end of this path. That path must start on the vertex at which
   *   this path ends.
   * @returns the newly created path.
   */
  concat(tailPath: GraphPath<TTrigger, Vertex, TNullEdge>): GraphPath<TTrigger, RV, TNullEdge> {
    assert(this.tail.index === tailPath.root.index, () => `Cannot concat ${tailPath} after ${this}`);
    if (tailPath.size === 0) {
      return this;
    }

    let prevRuntimeTypes = this.runtimeTypesBeforeTailIfLastIsCast;
    let runtimeTypes = this.runtimeTypesOfTail;
    for (const [edge] of tailPath.elements()) {
      prevRuntimeTypes = runtimeTypes;
      runtimeTypes = updateRuntimeTypes(runtimeTypes, edge);
    }
    return new GraphPath(
      this.graph,
      this.root,
      tailPath.tail,
      this.edgeTriggers.concat(tailPath.edgeTriggers),
      this.edgeIndexes.concat(tailPath.edgeIndexes),
      this.edgeConditions.concat(tailPath.edgeConditions),
      tailPath.edgeToTail,
      runtimeTypes,
      tailPath.edgeToTail?.transition?.kind === 'DownCast' ? prevRuntimeTypes : undefined
    );
  }

  /**
   * The set of edges that may legally continue this path.
   */
  nextEdges(): readonly Edge[] {
    return this.graph.outEdges(this.tail);
  }

  /**
   * Whether the path is terminal, that is ends on a terminal vertex.
   */
  isTerminal() {
    return this.graph.isTerminal(this.tail);
  }

  /**
   * Whether this path is a `RootPath`, that is one whose starting vertex is one of the underlying query graph root.
   */
  isRootPath(): this is RootPath<TTrigger, TNullEdge> {
    return isRootVertex(this.root);
  }

  mapMainPath<T>(mapper: (e: Edge | TNullEdge, pathIdx: number) => T): T[] {
    const result = new Array(this.size);
    let v: Vertex = this.root;
    for (let i = 0; i < this.size; i++) {
      const edge = this.edgeAt(i, v);
      result[i] = mapper(edge, i);
      if (edge) {
        v = edge.tail;
      }
    }
    return result;
  }

  private edgeAt(index: number, v: Vertex): Edge | TNullEdge {
    const edgeIdx = this.edgeIndexes[index];
    return (edgeIdx !== null ? this.graph.outEdge(v, edgeIdx) : null) as Edge | TNullEdge;
  }

  reduceMainPath<T>(reducer: (accumulator: T, edge: Edge | TNullEdge, pathIdx: number) => T, initialValue: T): T {
    let value = initialValue;
    let v: Vertex = this.root;
    for (let i = 0; i < this.size; i++) {
      const edge = this.edgeAt(i, v);
      value = reducer(value, edge, i);
      if (edge) {
        v = edge.tail;
      }
    }
    return value;
  }

  /**
   * Whether the path forms a cycle on the its end vertex, that is if the end vertex of this path has already been encountered earlier in the path.
   */
  hasJustCycled(): boolean {
    if (this.root.index == this.tail.index) {
      return true;
    }
    let v: Vertex = this.root;
    // We ignore the last edge since it's the one leading to the current vertex.
    for (let i = 0; i < this.size - 1; i++) {
      const edge = this.edgeAt(i, v);
      if (!edge) {
        continue;
      }
      v = edge.tail;
      if (v.index == this.tail.index) {
        return true;
      }
    }
    return false;
  }

  /**
   * Whether any of the edge in the path has associated conditions paths.
   */
  hasAnyEdgeConditions(): boolean {
    return this.edgeConditions.some(c => c !== null);
  }

  isOnTopLevelQueryRoot(): boolean {
    if (!isRootVertex(this.root)) {
      return false;
    }
    // We walk the vertices and as soon as we move out of the Query type,
    // we know we're not on the top-query root anymore. The reason we don't
    // just check that size <= 1 is that we could have top-leve `... on Query`
    // conditions that don't actually move us.
    let vertex: Vertex = this.root;
    for (let i = 0; i < this.size; i++) {
      const edge = this.edgeAt(i, vertex);
      if (!edge) {
        continue;
      }
      if (edge.tail.type.name !== "Query") {
        return false;
      }
      vertex = edge.tail;
    }
    return true;
  }

  toString(): string {
    const isRoot = isRootVertex(this.root);
    if (isRoot && this.size === 0) {
      return '_';
    }
    const pathStr = this.mapMainPath((edge, idx) => {
      if (edge) {
        if (isRoot && idx == 0) {
          return edge.tail.toString();
        }
        const label = edge.label();
        return ` -${label === "" ? "" : '-[' + label + ']-'}-> ${edge.tail}`
      }
      return ` (${this.edgeTriggers[idx]}) `;
    }).join('');
    return `${isRoot ? '' : this.root}${pathStr} (types: [${this.runtimeTypesOfTail.join(', ')}])`;
  }
}

/**
 * A `GraphPath` that starts on a vertex that is a root vertex (of the query graph of which this is a path).
 */
export type RootPath<TTrigger, TNullEdge extends null | never = never> = GraphPath<TTrigger, RootVertex, TNullEdge>;

/**
 * A `GraphPath` whose triggers are `OperationElement` (essentially meaning that the path has been guided by a graphQL query).
 */
export type OpGraphPath<RV extends Vertex = Vertex> = GraphPath<OperationElement | PathContext, RV, null>;

/**
 * An `OpGraphPath` that starts on a vertex that is a root vertex (of the query graph of which this is a path).
 */
export type OpRootPath = OpGraphPath<RootVertex>;

export function isRootPath(path: OpGraphPath<any>): path is OpRootPath {
  return isRootVertex(path.root);
}

export function traversePath(
  path: GraphPath<any>,
  onEdges: (edge: Edge) => void
){
  for (const [edge, _, conditions] of path.elements()) {
    if (conditions) {
      traversePathTree(conditions, onEdges);
    }
    onEdges(edge);
  }
}

export type ConditionResolver = (conditions: SelectionSet, vertex: Vertex, excludedEdges: ExcludedEdges, excludedConditions: ExcludedConditions) => null | [OpPathTree, number] | undefined;


export enum UnadvanceableReason {
  UNSATISFIABLE_KEY_CONDITION,
  UNSATISFIABLE_REQUIRES_CONDITION,
  NO_MATCHING_TRANSITION,
  UNREACHABLE_TYPE,
}

export type Unadvanceable = {
  sourceSubgraph: string,
  destSubgraph: string,
  reason: UnadvanceableReason,
  details: string
};

export class Unadvanceables {
  constructor(readonly reasons: Unadvanceable[]) {}
}

export function isUnadvanceable<V extends Vertex>(result: GraphPath<Transition, V>[] | Unadvanceables): result is Unadvanceables {
  return result instanceof Unadvanceables;
}

// Note: conditions resolver should return `null` if the condition cannot be satisfied. If it is satisfied, it has the choice of computing
// the actual tree, which we need for query planning, or simply returning "undefined" which means "The condition can be satisfied but I didn't
// bother computing a tree for it", which we use for simple validation.


// Returns undefined if there is no way to advance the path with this transition. Otherwise, it returns a list of options (paths) we can be in after advancing the transition.
// The lists of options can be empty, which has the special meaning that the transition is guaranteed to have no results (it corresponds to unsatisfiable conditions),
// meaning that as far as composition validation goes, we can ignore that transition (and anything that follows) and otherwise continue.
export function advancePathWithTransition<V extends Vertex>(
  supergraph: Schema,
  subgraphPath: GraphPath<Transition, V>,
  transition: Transition,
  targetType: NamedType,
  conditionResolver: ConditionResolver,
  cache: QueryGraphState<IndirectPaths<Transition>>
) : GraphPath<Transition, V>[] | Unadvanceables {
  // The `transition` comes from the supergraph. Now, it is possible that a transition can be expressed on the supergraph, but correspond
  // to an 'unsatisfiable' condition on the subgraph. Let's consider:
  // - Subgraph A:
  //    type Query {
  //       get: [I]
  //    }
  //
  //    interface I {
  //      k: Int
  //    }
  //
  //    type T1 implements I @key(fields: "k") {
  //      k: Int
  //      a: String
  //    }
  //
  //    type T2 implements I @key(fields: "k") {
  //      k: Int
  //      b: String
  //    }
  //
  // - Subgraph B:
  //    interface I {
  //      k: Int
  //    }
  //
  //    type T1 implements I @key(fields: "k") {
  //      k: Int
  //      myself: I
  //    }
  //
  // On the resulting supergraph, we will have a path for:
  //   {
  //     get {
  //       ... on T1 {
  //         myself {
  //           ... on T2 {
  //             b
  //           }
  //         }
  //       }
  //     }
  //   }
  //
  // However, as we compute possible subgraph paths, the `myself` field will get us
  // in subgraph `B` through `T1`'s key. But then, as we look at transition `... on T2`
  // from subgraph `B`, we have no such type/transition. But this does not mean that
  // the subgraphs shouldn't compose. What it really means is that the corresponding
  // query above can be done, but is guaranteed to never return anything (essentially,
  // we can query subgraph 'B' but will never get a `T2` so the result of the query
  // should be empty).
  //
  // So we need to handle this case and we do this first. Note that the only kind of
  // transition that can give use this is a 'DownCast' transition.
  if (transition.kind === 'DownCast') {
    // If we consider a 'downcast' transition, it means that the target of that cast is composite, but also that the
    // last type of the subgraph path also is (that type is essentially the "source" of the cast).
    const supergraphRuntimeTypes = possibleRuntimeTypes(targetType as CompositeType);
    const subgraphRuntimeTypes = subgraphPath.tailPossibleRuntimeTypes();
    const intersection = supergraphRuntimeTypes.filter(t1 => subgraphRuntimeTypes.some(t2 => t1.name === t2.name)).map(t => t.name);
    // if we intersection is empty, it means whatever field got us here can never resolve into an object of the type we're casting
    // into. Essentially, we're good building a plan for this transition and whatever comes next: it'll just return nothing.
    if (intersection.length === 0) {
      debug.log(() => `No intersection between casted type ${targetType} and the possible types in this subgraph`);
      return [];
    }
  }

  debug.group(() => `Trying to advance ${subgraphPath} for ${transition}`);
  debug.group('Direct options:');
  const directOptions = advancePathWithDirectTransition(supergraph, subgraphPath, transition, conditionResolver);
  let options: GraphPath<Transition, V>[];
  const deadEnds: Unadvanceable[] = [];
  if (isUnadvanceable(directOptions)) {
    options = [];
    debug.groupEnd(() => 'No direct options');
    deadEnds.push(...directOptions.reasons);
  } else {
    debug.groupEnd(() => advanceOptionsToString(directOptions));
    // If we can fullfill the transition directly (without taking an edge) and the target type is "terminal", then there is
    // no point in computing all the options.
    if (directOptions.length > 0 && isLeafType(targetType)) {
      debug.groupEnd(() => `reached leaf type ${targetType} so not trying indirect paths`);
      return directOptions;
    }
    options = directOptions;
  }
  // Otherwise, let's try non-collecting edges and see if we can find some (more) options there.
  debug.group(`Computing indirect paths:`);
  const pathsWithNonCollecting = advancePathWithNonCollectingAndTypePreservingTransitions(
    subgraphPath,
    emptyContext,
    conditionResolver,
    [],
    [],
    t => t, cache
  );
  if (pathsWithNonCollecting.paths.length > 0) {
    debug.groupEnd(() => `${pathsWithNonCollecting.paths.length} indirect paths`);
    debug.group('Validating indirect options:');
    for (const nonCollectingPath of pathsWithNonCollecting.paths) {
      debug.group(() => `For indirect path ${nonCollectingPath}:`);
      const pathsWithTransition = advancePathWithDirectTransition(supergraph, nonCollectingPath, transition, conditionResolver);
      if (isUnadvanceable(pathsWithTransition)) {
        debug.groupEnd(() => `Cannot be advanced with ${transition}`);
        deadEnds.push(...pathsWithTransition.reasons);
      } else {
        debug.groupEnd(() => `Adding valid option: ${pathsWithTransition}`);
        options = options.concat(pathsWithTransition);
      }
    }
    debug.groupEnd();
  } else {
    debug.groupEnd('no indirect paths');
  }
  debug.groupEnd(() => options.length > 0 ? advanceOptionsToString(options) : `Cannot advance ${transition} for this path`);
  if (options.length > 0) {
    return options;
  }

  const allDeadEnds = deadEnds.concat(pathsWithNonCollecting.deadEnds.reasons);
  if (transition.kind === 'FieldCollection') {
    const typeName = transition.definition.parent!.name;
    const fieldName = transition.definition.name;
    const subgraphsWithDeadEnd = new Set(allDeadEnds.map(e => e.destSubgraph));
    for (const [subgraph, schema] of subgraphPath.graph.sources.entries()) {
      if (subgraphsWithDeadEnd.has(subgraph)) {
        continue;
      }
      const type = schema.type(typeName);
      if (type && isCompositeType(type) && type.field(fieldName)) {
        // That subgraph has the type we look for, but we have recorded no dead-ends. This means there is no edge to that type,
        // and thus that it has no keys.
        assert(!type.hasAppliedDirective(keyDirectiveName), () => `Expected type ${type} in ${subgraph} to not have keys`);
        allDeadEnds.push({
          sourceSubgraph: subgraphPath.tail.source,
          destSubgraph: subgraph,
          reason: UnadvanceableReason.UNREACHABLE_TYPE,
          details: `cannot move to subgraph "${subgraph}", which has field "${transition.definition.coordinate}", because type "${typeName}" has no @key defined in subgraph "${subgraph}"`
        });
      }
    }
  }

  return new Unadvanceables(allDeadEnds);
}

// A set of excluded edges, that is a pair of a head vertex index and an edge index (since edge indexes are relative to their vertex).
export type ExcludedEdges = readonly [number, number][];

function isEdgeExcluded(edge: Edge, excluded: ExcludedEdges): boolean {
  return excluded.some(([vIdx, eIdx]) => edge.head.index === vIdx && edge.index === eIdx);
}

function addEdgeExclusion(excluded: ExcludedEdges, newExclusion: Edge): ExcludedEdges {
  return excluded.concat([[newExclusion.head.index, newExclusion.index]]);
}

function isPathExcluded<TTrigger, V extends Vertex, TNullEdge extends null | never = never>(
  path: GraphPath<TTrigger, V, TNullEdge>,
  excludedEdges: ExcludedEdges,
  excludedConditions: ExcludedConditions
): boolean {
  for (const [e] of path.elements()) {
    if (e && (isEdgeExcluded(e, excludedEdges) || isConditionExcluded(e.conditions, excludedConditions))) {
      return true;
    }
  }
  return false;
}

export type ExcludedConditions = readonly SelectionSet[];

function isConditionExcluded(condition: SelectionSet | undefined, excluded: ExcludedConditions): boolean {
  if (!condition) {
    return false;
  }
  return excluded.find(e => condition.equals(e)) !== undefined;
}

function addConditionExclusion(excluded: ExcludedConditions, newExclusion: SelectionSet | undefined): ExcludedConditions {
  return newExclusion ? excluded.concat(newExclusion) : excluded;
}

function popMin<TTrigger, V extends Vertex, TNullEdge extends null | never = never>(
  paths: GraphPath<TTrigger, V, TNullEdge>[]
): GraphPath<TTrigger, V, TNullEdge> {
  let minIdx = 0;
  let minSize = paths[0].size;
  for (let i = 1; i < paths.length; i++) {
    if (paths[i].size < minSize) {
      minSize = paths[i].size;
      minIdx = i;
    }
  }
  const min = paths[minIdx];
  paths.splice(minIdx, 1);
  return min;
}

export type IndirectPaths<TTrigger, V extends Vertex = Vertex, TNullEdge extends null | never = never, TDeadEnds extends Unadvanceables | never = Unadvanceables> = {
  paths: GraphPath<TTrigger, V, TNullEdge>[],
  deadEnds: TDeadEnds
}

function advancePathWithNonCollectingAndTypePreservingTransitions<TTrigger, V extends Vertex, TNullEdge extends null | never = never, TDeadEnds extends Unadvanceables | never = Unadvanceables>(
  path: GraphPath<TTrigger, V, TNullEdge>,
  context: PathContext,
  conditionResolver: ConditionResolver,
  excludedEdges: ExcludedEdges,
  excludedConditions: ExcludedConditions,
  convertTransitionWithCondition: (transition: Transition, context: PathContext) => TTrigger,
  cache: QueryGraphState<IndirectPaths<TTrigger, Vertex, TNullEdge, TDeadEnds>>,
): IndirectPaths<TTrigger, V, TNullEdge>  {
  // We ignore the first edge when decide if a top-level path because that first edge is out federated-graph fake edge. What
  // we care about below is to know if we're on a Query object at the very beginning of a query.
  const isTopLevelPath = path.isOnTopLevelQueryRoot();

  // if there is a context (some @skip/@include), we completely bypass the cache (because the context will need to be added to any key edges, and while
  // we could have a cache per-context, it doesn't seem worth it).
  if (!context.isEmpty()) {
    return advancePathWithNonCollectingAndTypePreservingTransitionsNoCache(
      path,
      context,
      conditionResolver,
      excludedEdges,
      excludedConditions,
      convertTransitionWithCondition,
      isTopLevelPath
    );
  }

  let cachedPaths = cache.getVertexState(path.tail);
  if (cachedPaths) {
    debug.log(() => `Will use cached paths [${cachedPaths?.paths}] (${cachedPaths?.deadEnds?.reasons.length ?? 0} dead ends recorded)`);
  } else {
    // We only cache where there was no excluded edges/conditions (that way we know we can always use the cache, whatever the excluded edges/conditions are
    // by excluding anything cached that has what is excluded).
    // We also don't cache when we're at the top-level, because we'll exclude edges between Query objects, but we want to use those later if we get back
    // to a Query object through a field
    if (isTopLevelPath || excludedEdges.length !== 0 || excludedConditions.length !== 0) {
      return advancePathWithNonCollectingAndTypePreservingTransitionsNoCache(
        path,
        context,
        conditionResolver,
        excludedEdges,
        excludedConditions,
        convertTransitionWithCondition,
        isTopLevelPath
      );
    }

    cachedPaths = advancePathWithNonCollectingAndTypePreservingTransitionsNoCache(
      GraphPath.create(path.graph, path.tail),
      context,
      conditionResolver,
      [],
      [],
      convertTransitionWithCondition,
      // Note that as we pass a partial path, the method wouldn't be able to infer this boolean on its own. This is why this
      // parameter exists in the first place.
      isTopLevelPath
    );
    debug.log(() => `For ${path.tail}, caching paths ${cachedPaths?.paths} (${cachedPaths?.deadEnds?.reasons.length ?? 0} dead ends recorded)`);
    cache.setVertexState(path.tail, cachedPaths);
  }

  let paths = cachedPaths.paths;
  if (excludedEdges.length > 0 || excludedConditions.length > 0) {
    paths = paths.filter(p => isPathExcluded(p, excludedEdges, excludedConditions));
  }
  return {
    paths: paths.map(p => path.concat(p)),
    deadEnds: cachedPaths.deadEnds
  };
}

function conditionTree(resolution: [OpPathTree, number] | undefined): OpPathTree | undefined {
  return resolution ? resolution[0] : undefined;
}

function advancePathWithNonCollectingAndTypePreservingTransitionsNoCache<TTrigger, V extends Vertex, TNullEdge extends null | never = never, TDeadEnds extends Unadvanceables | never = Unadvanceables>(
  path: GraphPath<TTrigger, V, TNullEdge>,
  context: PathContext,
  conditionResolver: ConditionResolver,
  excludedEdges: ExcludedEdges,
  excludedConditions: ExcludedConditions,
  convertTransitionWithCondition: (transition: Transition, context: PathContext) => TTrigger,
  isTopLevelPath: boolean
): IndirectPaths<TTrigger, V, TNullEdge, TDeadEnds>  {
  const typeName = isFederatedGraphRootType(path.tail.type) ? undefined : path.tail.type.name;
  const originalSource = path.tail.source;
  const bestPathBySource = new Map<string, [GraphPath<TTrigger, V, TNullEdge>, number]>();
  const deadEnds: Unadvanceable[] = [];
  const toTry = [ path ];
  while (toTry.length > 0) {
    // Note that through `excluded` we avoid taking the same edge from multiple options. But that means it's important we try
    // the smallest paths first. That is, if we could in theory have path A -> B and A -> C -> B, and we can do B -> D,
    // then we want to keep A -> B -> D, not A -> C -> B -> D.
    const toAdvance = popMin(toTry);
    const nextEdges =  toAdvance.nextEdges().filter(e => !e.transition.collectOperationElements);
    if (nextEdges.length === 0) {
      debug.log(`Nothing to try for ${toAdvance}: it has no non-collecting outbound edges`);
      continue;
    }
    debug.group(() => `From ${toAdvance}:`);
    for (const edge of nextEdges) {
      debug.group(`Testing edge ${edge}`);
      if (isEdgeExcluded(edge, excludedEdges)) {
        debug.groupEnd(`Ignored: edge is excluded`);
        continue;
      }
      excludedEdges = addEdgeExclusion(excludedEdges, edge);

      if (isConditionExcluded(edge.conditions, excludedConditions)) {
        debug.groupEnd(`Ignored: edge condition is excluded`);
        continue;
      }

      // We can only take a non-collecting transition that preserves the current type (typically,
      // jumping subgraphs through a key), with the exception of the federated graph roots, where
      // the type is fake and jumping to any given subgraph is ok and desirable.
      // Also, if the edge takes us back to the subgraph in which we started, we're not really interested
      // (we've already checked for direct transition from that original subgraph).
      const target = edge.tail;
      if (target.source === originalSource) {
        debug.groupEnd('Ignored: edge get us back to our original source');
        continue;
      }
      if (typeName && typeName != target.type.name) {
        debug.groupEnd('Ignored: edge does not get to our target type');
        continue;
      }

      // We have edges between Query objects so that if a field returns a query object, we can jump to any subgraph
      // at that point. However, there is no point of using those edges at the beginning of a path.
      if (isTopLevelPath && edge.transition.kind === 'QueryResolution') {
        debug.groupEnd(`Ignored: edge is a top-level "QueryResolution"`);
        continue;
      }

      const prevForSource = bestPathBySource.get(target.source);
      if (prevForSource
        && (prevForSource[0].size < toAdvance.size + 1
          || (prevForSource[0].size == toAdvance.size + 1 && prevForSource[1] <= 1)
        )
      ) {
        // We've already found another path that gets us to the same subgraph than the edge we're
        // about to check. If that previous path is strictly shorter than the path we'd obtain
        // with the new edge, then we don't consider this edge (it's a longer way to get to the same place).
        // And if the previous path is the same size (as the one obtained with that edge), but
        // that the previous path cost for getting the condition was 0 or 1, then the new edge cannot
        // really improve on this and we don't bother with it. Note that a cost of 0 can only happen
        // during composition validation where all costs are 0 to mean "we don't care about costs".
        // Meaning effectively that for validation, as soon as we have a path to a subgraph, we ignore
        // other options even if they may be "faster".
        debug.groupEnd(`Ignored: a better path to the same subgraph already added`);
        continue;
      }

      debug.group(() => `Validating conditions ${edge.conditions}`);
      const [isSatisfied, resolution] = canSatisfyConditions(
        toAdvance,
        edge,
        conditionResolver,
        excludedEdges,
        addConditionExclusion(excludedConditions, edge.conditions)
      );
      if (isSatisfied) {
        debug.groupEnd('Condition satisfied');
        const cost = resolution ? resolution[1] : 0;
        // We _can_ get to `taget.source` with that edge. But if we had already found another path to
        // the same subgraph, we want to replace it by this one only if either 1) it is shorter or 2) if
        // it's of equal size, only if the condition cost are lower than the previous one.
        if (prevForSource && prevForSource[0].size === toAdvance.size + 1 && prevForSource[1] <= cost) {
          debug.groupEnd('Ignored: a better path to the same subgraph already added');
          continue;
        }
        const updatedPath = toAdvance.add(convertTransitionWithCondition(edge.transition, context), edge, conditionTree(resolution));
        debug.log(() => `Using edge, advance path: ${updatedPath}`);
        bestPathBySource.set(target.source, [updatedPath, cost]);
        // It can be necessary to "chain" keys, because different subgraphs may have different keys exposed, and so we when we took
        // a key, we want to check if there is new key we can now take that take us to other subgraphs. For other 'non-collecting'
        // edges ('QueryResolution' and 'SubgraphEnteringTransition') however, chaining never give us additional value.
        if (edge.transition.kind === 'KeyResolution') {
          toTry.push(updatedPath);
        }
      } else {
        debug.groupEnd('Condition unsatisfiable');
        deadEnds.push({
          sourceSubgraph: toAdvance.tail.source,
          destSubgraph: edge.tail.source,
          reason: UnadvanceableReason.UNSATISFIABLE_KEY_CONDITION,
          details: `cannot move to subgraph "${edge.tail.source}" using @key(fields: "${edge.conditions?.toString(false)}") of "${edge.head.type}", the key field(s) cannot be resolved from subgraph "${toAdvance.tail.source}"`
        });
      }
      debug.groupEnd(); // End of edge
    }
    debug.groupEnd();
  }
  return {
    paths: mapValues(bestPathBySource).map(b => b[0]),
    deadEnds: new Unadvanceables(deadEnds) as TDeadEnds
  }
}

function advancePathWithDirectTransition<V extends Vertex>(
  supergraph: Schema,
  path: GraphPath<Transition, V>,
  transition: Transition,
  conditionResolver: ConditionResolver
) : GraphPath<Transition, V>[] | Unadvanceables {
  const options: GraphPath<Transition, V>[] = [];
  const deadEnds: Unadvanceable[] = [];

  for (const edge of path.nextEdges()) {
    // The edge must match the transtion and get us to the target type.
    if (!transition.collectOperationElements || !edge.matchesSupergraphTransition(supergraph, transition)) {
      continue;
    }

    // Additionaly, we can only take an edge if we can satisfy its conditions.
    const [isSatisfied, resolution] = canSatisfyConditions(path, edge, conditionResolver, [], []);
    if (isSatisfied) {
      options.push(path.add(transition, edge, conditionTree(resolution)));
    } else {
      // The only direct transitions are fields and typeCast, and the later cannot have conditions (the former can, and it
      // is a @require).
      assert(transition.kind === 'FieldCollection', () => `Shouldn't have conditions on direct transition ${transition}`);
      const field = transition.definition;
      const parentTypeInSubgraph = path.graph.sources.get(edge.head.source)!.type(field.parent!.name)! as CompositeType;
      deadEnds.push({
        sourceSubgraph: edge.head.source,
        destSubgraph: edge.head.source,
        reason: UnadvanceableReason.UNSATISFIABLE_REQUIRES_CONDITION,
        details: `cannot satisfy @require conditions on field "${field.coordinate}"${warnOnKeyFieldsMarkedExternal(parentTypeInSubgraph)}`
      });
    }
  }
  if (options.length > 0) {
    return options;
  } else if (deadEnds.length > 0) {
    return new Unadvanceables(deadEnds);
  } else {
    let details: string;
    const subgraph = path.tail.source;
    if (transition.kind === 'FieldCollection') {
      const schema = path.graph.sources.get(subgraph)!;
      const typeInSubgraph = schema.type(path.tail.type.name);
      const fieldInSubgraph = typeInSubgraph && isCompositeType(typeInSubgraph)
        ? typeInSubgraph.field(transition.definition.name)
        : undefined;

      if (fieldInSubgraph) {
        // the subgraph has the field but no correspond edge. This should only happen if the field is external.
        assert(
          fieldInSubgraph.hasAppliedDirective('external'), 
          () => `${fieldInSubgraph.coordinate} in ${subgraph} is not external but there is no corresponding edge (edges from ${path} = [${path.nextEdges().join(', ')}])`
        );
        details = `field "${transition.definition.coordinate}" is not resolvable because marked @external`;
      } else {
        details = `cannot find field "${transition.definition.coordinate}"`;
      }
    } else {
      assert(transition.kind === 'DownCast', () => `Unhandled direct transition ${transition} of kind ${transition.kind}`);
      details = `cannot find type "${transition.castedType}"`;
    }
    return new Unadvanceables([{
      sourceSubgraph: subgraph,
      destSubgraph: subgraph,
      reason: UnadvanceableReason.NO_MATCHING_TRANSITION,
      details
    }]);
  }
}

function warnOnKeyFieldsMarkedExternal(type: CompositeType): string {
  // Because fed 1 used to (somewhat wrongly) require @external on key fields of type extension and because fed 2 allows you
  // to avoid type extensions, users upgrading might try to remove `extend` from their schema, but forgot to remove the @external
  // on their key field. The problem is that doing that make the key field truly external, and that could easily make @require
  // condition no satisfiable (because the key you'd need to get the require is now external). To help user locate that mistake
  // we add a specific pointer to this potential problem is the type is indeed an entity.
  const keyDirective = federationBuiltIns.keyDirective(type.schema()!);
  const keys = type.appliedDirectivesOf(keyDirective);
  if (keys.length === 0) {
    return "";
  }
  const keyFieldMarkedExternal: string[] = [];
  for (const key of keys) {
    const fieldSet = parseFieldSetArgument(type, key);
    for (const selection of fieldSet.selections()) {
      if (selection.kind === 'FieldSelection' && selection.field.definition.hasAppliedDirective(externalDirectiveName)) {
        const fieldName = selection.field.name;
        if (!keyFieldMarkedExternal.includes(fieldName)) {
          keyFieldMarkedExternal.push(fieldName);
        }
      }
    }
  }
  if (keyFieldMarkedExternal.length === 0) {
    return "";
  }
  const printedFields = keyFieldMarkedExternal.map(f => `"${f}"`).join(', ');
  const fieldWithPlurar = keyFieldMarkedExternal.length === 1 ? 'field' : 'fields';
  return ` (please ensure that this is not due to key ${fieldWithPlurar} ${printedFields} being accidentally marked @external)`;
}

export function requireEdgeAdditionalConditions(edge: Edge): SelectionSet {
  // We need to add _one_ of the current entity key as condition. We pick the first one we find,
  // which is not perfect, as maybe we can't satisfy that key but we could another, but this ensure
  // query planning later knows which keys to use. We'd have to communicate that somehow otherwise.
  const type = edge.head.type as CompositeType;
  const keyDirective = federationBuiltIns.keyDirective(type.schema()!);
  const keyDirectives = type.appliedDirectivesOf(keyDirective);
  assert(keyDirectives.length > 0, () => `We should have a require on ${edge} if ${type} has no key directive`);
  return parseFieldSetArgument(type, keyDirectives[0]);
}

function canSatisfyConditions<TTrigger, V extends Vertex, TNullEdge extends null | never = never>(
  path: GraphPath<TTrigger, V, TNullEdge>,
  edge: Edge,
  conditionResolver: ConditionResolver,
  excludedEdges: ExcludedEdges,
  excludedConditions: ExcludedConditions
): [boolean, [OpPathTree, number] | undefined] {
  const conditions = edge.conditions;
  if (!conditions) {
    return [true, undefined];
  }
  const resolution = conditionResolver(conditions, path.tail, excludedEdges, excludedConditions);
  if (resolution === null) {
    return [false, undefined];
  }
  let pathTree = resolution ? resolution[0] : undefined;
  const lastEdge = path.lastEdge();
  if (edge.transition.kind === 'FieldCollection'
    && lastEdge !== null
    && lastEdge?.transition.kind !== 'KeyResolution'
    && (!pathTree || pathTree.isAllInSameSubgraph())) {
    const additionalConditions = requireEdgeAdditionalConditions(edge);
    const additionalResolution = conditionResolver(additionalConditions, path.tail, excludedEdges, excludedConditions);
    if (additionalResolution === null) {
      return [false, undefined];
    }
    if (pathTree) {
      pathTree = pathTree.merge(additionalResolution![0]);
    }
  }
  return [true, resolution ? [pathTree!, resolution[1]] : undefined];
}

function isTerminalOperation(operation: OperationElement): boolean {
  return operation.kind === 'Field' && isLeafType(baseType(operation.definition.type!));
}

function isNonConditionFragment(type: NamedType, operation: OperationElement): boolean {
  return operation.kind === 'FragmentElement' && (!operation.typeCondition || operation.typeCondition.name === type.name);
}

export type SimultaneousPaths<V extends Vertex = Vertex> = OpGraphPath<V>[];

export function simultaneousPathsToString(paths: SimultaneousPaths<any>, indentOnNewLine: string=""): string {
  if (paths.length === 0) {
    return '<no path>';
  }
  if (paths.length === 1) {
    return paths[0].toString();
  }
  return `{\n${indentOnNewLine}  ` + paths.join(`\n${indentOnNewLine}  `) + `\n${indentOnNewLine}}`;
}

export function advanceOptionsToString(options: (SimultaneousPaths<any>| GraphPath<any>)[] | undefined): string {
  if (!options) {
    return '<no options>';
  }
  if (options.length === 0) {
    return '<unsatisfiable branch>';
  }
  if (options.length === 1) {
    return '[' + options[0] + ']';
  }
  return '[\n  ' + options.map(opt => Array.isArray(opt) ? simultaneousPathsToString(opt, "  ") : opt.toString()).join('\n  ') + '\n]';
}

// Returns undefined if the operation cannot be dealt with/advanced. Otherwise, it returns a list of options we can be in after advancing the operation, each option
// being a set of simultaneous paths in the subgraphs (a single path in the simple case, but type explosing may make us explore multiple paths simultaneously).
// The lists of options can be empty, which has the special meaning that the operation is guaranteed to have no results (it corresponds to unsatisfiable conditions),
// meaning that as far as query planning goes, we can just ignore the operation but otherwise continue.
export function advanceSimultaneousPathsWithOperation<V extends Vertex>(
  supergraphSchema: Schema,
  subgraphSimultaneousPaths: SimultaneousPaths<V>,
  operation: OperationElement,
  context: PathContext,
  conditionResolver: ConditionResolver,
  cache: QueryGraphState<OpIndirectPaths>,
  excludedNonCollectingEdges: ExcludedEdges = [],
  excludedConditionsOnNonCollectingEdges: ExcludedConditions = []
) : SimultaneousPaths<V>[] | undefined {
  debug.group(() => `Trying to advance ${simultaneousPathsToString(subgraphSimultaneousPaths)} for ${operation}`);
  debug.group('Direct options:');
  let options = advanceWithOperation(supergraphSchema, subgraphSimultaneousPaths, operation, context, conditionResolver, cache);
  debug.groupEnd(() => advanceOptionsToString(options));
  // Like with transitions, if we can find a terminal field with a direct edge, there is no point in trying to
  // take indirect paths (this is not true for non-terminal, because for those, the direct paths may be dead ends,
  // but for terminal, we're at the end so ...).
  // Similarly, if we gets options but an empty set, it means the operation correspond to unsatisfiable conditions and we
  // can essentially ignore it. So no point in trying to take non-collecting edges.
  // Lastly, we have the case of a fragment that doesnt change the type (no type condition or the condition is the current type).
  // In that case too there is no point in looking for non-collecting edges since the "next" operation will be able to
  // take the same exact edges (we're staying on the same type) but have more context to do so. In fact, it's better not to
  // take those edges (yet) in general as the condition might have a skip/include, and it's more efficient to apply those skip/include
  // as soon as possible (so before taking an edge if we end up taking one).
  if (options && (options.length === 0 || isTerminalOperation(operation) || (isNonConditionFragment(subgraphSimultaneousPaths[0].tail.type, operation)))) {
    debug.groupEnd(() => advanceOptionsToString(options));
    return options;
  }
  // If there was not valid direct path, that's ok, we'll just try with non-collecting edges.
  options = options ?? [];
  debug.group(`Computing indirect paths:`);
  // Then adds whatever options can be obtained by taking some non-collecting edges first.
  const pathsWithNonCollecting = advanceAllWithNonCollectingAndTypePreservingTransitions(
    subgraphSimultaneousPaths,
    context,
    conditionResolver,
    excludedNonCollectingEdges,
    excludedConditionsOnNonCollectingEdges,
    cache
  );
  debug.groupEnd(() => pathsWithNonCollecting.length == 0 ? `no indirect paths` : `${pathsWithNonCollecting.length} indirect paths`);
  if (pathsWithNonCollecting.length > 0) {
    debug.group('Validating indirect options:');
    for (const pathWithNonCollecting of pathsWithNonCollecting) {
      debug.group(() => `For indirect path ${pathWithNonCollecting}:`);
      const pathWithOperation = advanceWithOperation(supergraphSchema, pathWithNonCollecting, operation, context, conditionResolver, cache);
      // If we can't advance the operation after that path, ignore it, it's just not an option.
      if (!pathWithOperation) {
        debug.groupEnd(() => `Ignoring: cannot be advanced with ${operation}`);
        continue;
      }
      debug.groupEnd(() => `Adding valid option: ${pathWithOperation}`);
      // advancedWithOperation can return an empty list only if the operation if a fragment with a condition that, on top of the "current" type
      // is unsatisfiable. But as we've only taken type preserving transitions, we cannot get an empty results at this point if we haven't
      // had one when testing direct transitions above (in which case we have exited the method early).
      assert(pathWithOperation.length > 0, () => `Unexpected empty options after non-collecting path ${pathWithNonCollecting} for ${operation}`);
      options = options.concat(pathWithOperation);
    }
    debug.groupEnd();
  }
  // At this point, if options is empty, it means we found no ways to advance the operation, so we should return undefined.
  options = options.length === 0 ? undefined : options;
  debug.groupEnd(() => advanceOptionsToString(options));
  return options;
}

export type OpIndirectPaths<RV extends Vertex = Vertex> = IndirectPaths<OperationElement | PathContext, RV, null, never>;

function advanceAllWithNonCollectingAndTypePreservingTransitions<V extends Vertex>(
  paths: SimultaneousPaths<V>,
  context: PathContext,
  conditionResolver: ConditionResolver,
  excludedEdges: ExcludedEdges,
  excludedConditions: ExcludedConditions,
  cache: QueryGraphState<OpIndirectPaths>,
): SimultaneousPaths<V>[] {
  const optionsForEachPaths = paths.map(p => 
    advancePathWithNonCollectingAndTypePreservingTransitions(
      p,
      context,
      conditionResolver,
      excludedEdges,
      excludedConditions,
      // the transitions taken by this function are non collecting transitions, and we ship the context as trigger (a slight hack admittedly,
      // but as we'll need the context handy for keys ...).
      (_t, context) => context,
      cache
    ).paths
  );
  // optionsForEachPaths[i] is all the possible paths we could go from paths[i]. As each paths[i] is a set of "simultaneous" paths,
  // we need to compute the cartesien product of all those results.
  return cartesianProduct(optionsForEachPaths);
}


// The result has the same meaning than in advanceSimultaneousPathsWithOperation.
function advanceWithOperation<V extends Vertex>(
  supergraphSchema: Schema,
  simultaneousPaths: SimultaneousPaths<V>,
  operation: OperationElement,
  context: PathContext,
  conditionResolver: ConditionResolver,
  cache: QueryGraphState<OpIndirectPaths>
): SimultaneousPaths<V>[] | undefined {
  const newPaths: SimultaneousPaths<V>[][] = [];
  for (const path of simultaneousPaths) {
    const updated = advanceOneWithOperation(supergraphSchema, path, operation, context, conditionResolver, cache);
    // We must be able to apply the operation on all the simultaneous paths, otherwise the whole set of simultaneous paths cannot fullfill
    // the operation and we can abort early.
    if (!updated) {
      return undefined;
    }
    if (updated.length > 0) {
      newPaths.push(updated);
    }
  }

  // Each entry of newPaths is all the options for 1 of our simultaneous path. So what we want to return is all the options
  // composed of taking one of each element of newPaths. In other words, we want the cartesian product.
  return flatCartesianProduct(newPaths);
}

// This can be written more tersely with a bunch of reduce/flatMap and friends, but when interfaces type-explode into many
// implementations, this can end up with fairly large arrays and be a bottleneck, and a more iterative version that pre-allocate
// arrays is quite a bit faster.
function cartesianProduct<V>(arr:V[][]): V[][] {
  const size = arr.length;
  if (size === 0) {
    return [];
  }

  // Track, for each element, at which index we are
  const eltIndexes = new Array<number>(size);
  let totalCombinations = 1;
  for (let i = 0; i < size; ++i){
    const eltSize = arr[i].length;
    if(!eltSize) {
      totalCombinations = 0;
      break;
    }
    eltIndexes[i] = 0;
    totalCombinations *= eltSize;
  }

  const product = new Array<V[]>(totalCombinations);
  for (let i = 0; i < totalCombinations; ++i){
    const item = new Array<V>(size);
    for (var j = 0; j < size; ++j) {
      item[j] = arr[j][eltIndexes[j]];
    }
    product[i] = item;

    for (let idx = 0; idx < size; ++idx) {
      if (eltIndexes[idx] == arr[idx].length - 1) {
        eltIndexes[idx] = 0;
      } else {
        eltIndexes[idx] += 1;
        break;
      }
    }
  }
  return product;
}

function flatCartesianProduct<V>(arr:V[][][]): V[][] {
  const size = arr.length;
  if (size === 0) {
    return [];
  }

  // Track, for each element, at which index we are
  const eltIndexes = new Array<number>(size);
  let totalCombinations = 1;
  for (let i = 0; i < size; ++i){
    const eltSize = arr[i].length;
    if(!eltSize) {
      totalCombinations = 0;
      break;
    }
    eltIndexes[i] = 0;
    totalCombinations *= eltSize;
  }

  const product = new Array<V[]>(totalCombinations);
  for (let i = 0; i < totalCombinations; ++i){
    let itemSize = 0;
    for (var j = 0; j < size; ++j) {
      itemSize += arr[j][eltIndexes[j]].length;
    }
    const item = new Array<V>(itemSize);
    let k = 0;
    for (var j = 0; j < size; ++j) {
      for (const v of arr[j][eltIndexes[j]]) {
        item[k++] = v;
      }
    }
    product[i] = item;

    for (let idx = 0; idx < size; ++idx) {
      if (eltIndexes[idx] == arr[idx].length - 1) {
        eltIndexes[idx] = 0;
      } else {
        eltIndexes[idx] += 1;
        break;
      }
    }
  }
  return product;
}

function anImplementationHasAProvides(fieldName: string, itf: InterfaceType): boolean {
  for (const implem of itf.possibleRuntimeTypes()) {
    const field = implem.field(fieldName);
    // Note that this should only be called if field exists, but no reason to fail otherwise.
    if (field && field.hasAppliedDirective(providesDirectiveName)) {
      return true;
    }
  }
  return false;
}


// The result has the same meaning than in advanceSimultaneousPathsWithOperation.
// We also actually need to return a set of options of simultaneous paths. Cause when we type explode, we create simultaneous paths, but
// as a field might be resolve by multiple subgraphs, we may have options created.
function advanceOneWithOperation<V extends Vertex>(
  supergraphSchema: Schema,
  path: OpGraphPath<V>,
  operation: OperationElement,
  context: PathContext,
  conditionResolver: ConditionResolver,
  cache: QueryGraphState<OpIndirectPaths>
) : SimultaneousPaths<V>[] | undefined {
  debug.group(() => `Trying to advance ${path} directly with ${operation}`);

  const currentType = path.tail.type;
  if (isFederatedGraphRootType(currentType)) {
    // We cannot advance any operation from there: we need to take the initial non-collecting edges first.
    debug.groupEnd('Cannot advance federated graph root with direct operations');
    return undefined;
  }

  if (operation.kind === 'Field') {
    const field = operation.definition;
    switch (currentType.kind) {
      case 'ObjectType':
        // Just take the edge corresponding to the field, if it exists and can be used.
        const edge = edgeForField(path, operation);
        if (!edge) {
          debug.groupEnd(() => `No edge for field ${field} on object type ${currentType}`);
          return undefined;
        }
        const fieldOptions = addFieldEdge(path, operation, edge, conditionResolver);
        debug.groupEnd(() => fieldOptions.length === 0
          ? `Cannot satisfy @requires on field ${field} for object type ${currentType}`
          : `Collected field ${field} on object type ${currentType}`
        );
        return fieldOptions;
      case 'InterfaceType':
        // First, we check if there is a direct edge from the interface (which only happens if we're in a subgraph that knows all of the
        // implementations of that interface globally and all of them resolve the field).
        // If there is one, then we have 2 options: either we take that edge, or we type-explode (like when we don't have a direct interface edge).
        // In general, taking the interface edge is better than type explosion. However, there is a special case: if the field has a @provides in
        // at least some of the implementations. In that case, it could be that type-exploding ends up faster because the @provides saves on a fetch
        // we have to do if we take the direct edge. So if any implementation has a @provides, we include both options (direct interface or type explosion
        // and let the later query-plan "cost" evaluation decide what is best).
        const itfEdge = edgeForField(path, operation);
        let itfOptions: SimultaneousPaths<V>[] | undefined = undefined;
        if (itfEdge) {
          itfOptions = addFieldEdge(path, operation, itfEdge, conditionResolver);
          // Further, if we've getting the __typename, we must _not_ type-explode.
          if (field.name === typenameFieldName || !anImplementationHasAProvides(field.name, currentType)) {
            debug.groupEnd(() => `Collecting field ${field} on interface ${currentType} without type-exploding`);
            return itfOptions;
          } else {
            debug.log(() => `Collecting field ${field} on interface ${currentType} as 1st option`);
          }
        }
        // Otherwise, that means we need to type explode and descend into every possible implementations (implementations "in the current
        // subraph", since the previous edge to this interface had to come from the current subgraph and can thus only have returned
        // local implementations).
        // TODO: once we add @key on interfaces, this will have to be updated.
        const implementations = path.tailPossibleRuntimeTypes();
        debug.log(() => itfOptions
          ? `No direct edge: type exploding interface ${currentType} into possible runtime types [${implementations.join(', ')}]`
          : `Type exploding interface ${currentType} into possible runtime types [${implementations.join(', ')}] as 2nd option`
        );
        // For all implementations, We need to call advanceSimultaneousPathsWithOperation on a made-up Fragment. If any
        // gives use empty options, we bail.
        const optionsByImplems: OpGraphPath<V>[][][] = [];
        for (const implemType of implementations) {
          const castOp = new FragmentElement(currentType, implemType.name);
          debug.group(() => `Handling implementation ${implemType}`);
          const implemOptions = advanceSimultaneousPathsWithOperation(
            supergraphSchema,
            [path],
            castOp,
            context,
            conditionResolver,
            cache
          );
          // If we find no option for that implementation, we bail (as we need to simultaneously advance all implementations).
          if (!implemOptions) {
            debug.groupEnd();
            debug.groupEnd(() => `Cannot collect field ${field} from ${implemType}: stopping with options ${advanceOptionsToString(itfOptions)}`);
            return itfOptions;
          }
          // If the new fragment makes it so that we're on an unsatisfiable branch, we just ignore that implementation.
          if (implemOptions.length === 0) {
            debug.groupEnd(() => `Cannot ever get ${implemType} from this branch, ignoring it`);
            continue;
          }
          // For each option, we call advanceSimultaneousPathsWithOperation again on our own operation (the field),
          // which gives us some options (or not and we bail).
          let withField: SimultaneousPaths<V>[] = [];
          debug.log(() => `Trying to collect ${field} from options ${advanceOptionsToString(implemOptions)}`);
          for (const optPaths of implemOptions) {
            debug.group(() => `For ${simultaneousPathsToString(optPaths)}`);
            const withFieldOptions = advanceSimultaneousPathsWithOperation(
              supergraphSchema,
              optPaths,
              operation,
              context,
              conditionResolver,
              cache
            );
            if (!withFieldOptions) {
              debug.groupEnd(() => `Cannot collect ${field}`);
              continue;
            }
            // Advancing a field should never get us into an unsatisfiable condition. Only fragments can.
            assert(withFieldOptions.length > 0, () => `Unexpected unsatisfiable path after ${optPaths} for ${operation}`);
            debug.groupEnd(() => `Collected field ${field}: adding ${advanceOptionsToString(withFieldOptions)}`);
            withField = withField.concat(withFieldOptions);
          }
          // If we find no option to advance that implementation, we bail (as we need to simultaneously advance all implementations).
          if (withField.length === 0) {
            debug.groupEnd(); // implem group
            debug.groupEnd(() => `Cannot collect field ${field} from ${implemType}: stopping with options ${advanceOptionsToString(itfOptions)}`);
            return itfOptions;
          }
          debug.groupEnd(() => `Collected field ${field} from ${implemType}`);
          optionsByImplems.push(withField);
        }
        const implemOptions = flatCartesianProduct(optionsByImplems);
        const allOptions = itfOptions ? itfOptions.concat(implemOptions) : implemOptions;
        debug.groupEnd(() => `With type-exploded options: ${advanceOptionsToString(allOptions)}`);
        return allOptions;
      case 'UnionType':
        assert(field.name === typenameFieldName, () => `Invalid field selection ${operation} for union type ${currentType}`);
        const typenameEdge = edgeForField(path, operation);
        assert(typenameEdge, `Should always have an edge for __typename edge on an union`);
        debug.groupEnd(() => `Trivial collection of __typename for union ${currentType}`);
        return addFieldEdge(path, operation, typenameEdge, conditionResolver);
      default:
        // Only object, interfaces and unions (only for __typename) have fields so the query should have been flagged invalid if a field was selected on something else.
        assert(false, `Unexpected ${currentType.kind} type ${currentType} from ${path.tail} given operation ${operation}`);
    }
  } else {
    assert(operation.kind === 'FragmentElement', () => "Unhandled operation kind: " + operation.kind);
    if (!operation.typeCondition || currentType.name === operation.typeCondition.name) {
      // If there is no typename (or the condition is the type we're already one), it means we're essentially
      // just applying some directives (could be a @skip/@include for instance). This doesn't make us take any
      // edge but if operation does have directives, we record it.
      debug.groupEnd(() => `No edge to take for condition ${operation} from current type ${currentType}`);
      const updatedPath = operation.appliedDirectives.length > 0
        ? path.add(operation, null)
        : path;
      return [[ updatedPath ]];
    }
    const typeName = operation.typeCondition.name;
    switch (currentType.kind) {
      case 'InterfaceType':
      case 'UnionType':
        // If we have an edge for the type case, take that.
        const edge = edgeForTypeCast(path, typeName);
        if (edge) {
          assert(!edge.conditions, "TypeCast collecting edges shouldn't have conditions");
          debug.groupEnd(() => `Using type-casting edge for ${typeName} from current type ${currentType}`);
          return [[path.add(operation, edge)]];
        }
        // Otherwise, checks what is the intersection between the possible runtime types of the current type
        // and the ones of the cast. We need to be able to go into all those types simultaneously.
        const parentTypes = path.tailPossibleRuntimeTypes() ;
        const castedTypes = possibleRuntimeTypes(supergraphSchema.type(typeName) as CompositeType);
        const intersection = parentTypes.filter(t1 => castedTypes.some(t2 => t1.name === t2.name)).map(t => t.name);
        debug.log(() => `Trying to type-explode into intersection between ${currentType} and ${typeName} = [${intersection}]`);
        const optionsByImplems: OpGraphPath<V>[][][] = [];
        for (const tName of intersection) {
          debug.group(() => `Trying ${tName}`);
          const castOp = new FragmentElement(currentType, tName);
          const implemOptions = advanceSimultaneousPathsWithOperation(
            supergraphSchema,
            [path],
            castOp,
            context,
            conditionResolver,
            cache
          );
          if (!implemOptions) {
            debug.groupEnd();
            debug.groupEnd(() => `Cannot advance into ${tName} from ${currentType}: no options for ${operation}.`);
            return undefined;
          }
          // If the new fragment makes it so that we're on an unsatisfiable branch, we just ignore that implementation.
          if (implemOptions.length === 0) {
            debug.groupEnd(() => `Cannot ever get ${tName} from this branch, ignoring it`);
            continue;
          }
          debug.groupEnd(() => `Advanced into ${tName} from ${currentType}: ${advanceOptionsToString(implemOptions)}`);
          optionsByImplems.push(implemOptions);
        }
        const allCastOptions = flatCartesianProduct(optionsByImplems);
        debug.groupEnd(() => `Type-exploded options: ${advanceOptionsToString(allCastOptions)}`);
        return allCastOptions;
      case 'ObjectType':
        // We've already handled the case of a fragment whose condition is this type. But the fragment might
        // be for either:
        // - a super-type of the current type: in which case, we're pretty much in the same case than if there
        //   were no particular condition.
        // - another, incompatible type. This can happen for a type that intersects a super-type of the
        //   current type (since graphQL allows a fragment as long as there is an intersection). In that
        //   case, the whole operation simply cannot ever return anything.
        const conditionType = supergraphSchema.type(typeName)!;
        if (isAbstractType(conditionType) && possibleRuntimeTypes(conditionType).some(t => t.name == currentType.name)) {
          debug.groupEnd(() => `${typeName} is a super-type of current type ${currentType}: no edge to take`);
          const updatedPath = operation.appliedDirectives.length > 0
            ? path.add(operation, null)
            : path;
          return [[ updatedPath ]];
        }
        // The operation we're dealing with can never return results (the type conditions applies have no intersection).
        // This means we _can_ fullfill this operation (by doing nothing and returning an empty result), which we indicate
        // by return an empty list of options.
        debug.groupEnd(() => `Cannot ever get ${typeName} from current type ${currentType}: returning empty branch`);
        return [];
      default:
        // We shouldn't have a fragment on a non-selectable type
        assert(false, `Unexpected ${currentType.kind} type ${currentType} from ${path.tail} given operation ${operation}`);
    }
  }
}

function addFieldEdge<V extends Vertex>(
  path: OpGraphPath<V>,
  fieldOperation: Field<any>,
  edge: Edge,
  conditionResolver: ConditionResolver
): OpGraphPath<V>[][] {
  const [isSatisfied, resolution] = canSatisfyConditions(path, edge, conditionResolver, [], []);
  return isSatisfied ? [[ path.add(fieldOperation, edge, conditionTree(resolution)) ]] : [];
}

function edgeForField<V extends Vertex>(
  path: OpGraphPath<V>,
  field: Field<any>
): Edge | undefined {
  const candidates = path.nextEdges().filter(e => e.transition.kind === 'FieldCollection' && field.selects(e.transition.definition, true));
  assert(candidates.length <= 1, () => `Vertex ${path.tail} has multiple edges matching ${field} (${candidates})`);
  return candidates.length === 0 ? undefined : candidates[0];
}

function edgeForTypeCast<V extends Vertex>(
  path: OpGraphPath<V>,
  typeName: string
): Edge | undefined {
  const candidates = path.nextEdges().filter(e => e.transition.kind === 'DownCast' && typeName === e.transition.castedType.name);
  assert(candidates.length <= 1, () => `Vertex ${path.tail} has multiple edges matching ${typeName} (${candidates})`);
  return candidates.length === 0 ? undefined : candidates[0];
}
