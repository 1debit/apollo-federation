---
title: CSDL Specification
sidebar_title: CSDL Specification
description: Formal description of the Composed Schema Definition Language format generated by composition.
status: Draft
version: "1.0.0"
authors: 
  - Jake Dawkins <jake@apollographql.com>
  - Trevor Scheer <trevor@apollographql.com>
  - Ashi Krishnan <ashi@apollographql.com>
---

<style>{`
  .not-csdl {
    border-left: 4px solid rgb(244, 208, 63);
    border-radius: 9px 0 0 0;
    padding: 0;
  }

  .not-csdl::before {
    display: block;
    content: "Note: Code is GraphQL SDL, not CSDL.";
    font-variant: italic;
    font-weight: bold;
    background: rgb(244, 208, 63);
    border-radius: 9px 9px 0 0;
    margin-left: -4px;
    padding: 6px;
    margin-bottom: -1px;
  }
`}</style>

## Introduction: What is CSDL?

The Composed Schema Definition Language (CSDL) provides a way to describe a GraphQL Schema which is composed from one or more other GraphQL schemas.

The CSDL is intended to be a single artifact which can power a graph router. For example, the CSDL replaces the service list configuration of Apollo Gateway.

CSDL is a subset of the [GraphQL Schema Definition Language](https://spec.graphql.org/). It removes certain SDL features (for instance, type extensions are not permitted) while also defining a suite of directives defining graph topology. In particular, the CSDL uses directives to:
- define [subgraphs](#def-subgraphs) and bind them to [endpoints](#def-endpoints) (with [`@graph`](#composedgraph-and-graph))
- assign fields to subgraphs (with [`@resolve`](#resolve))
- declare additional data required and provided by subgraph field resolvers (with [`@key`](#key), [`@requires`](#requires-and-provides), and [`@provides`](#requires-and-provides))      

## How to read this document

TK, discussion of spec nomenclature
e.g.: https://html.spec.whatwg.org/multipage/introduction.html#how-to-read-this-specification

### What this document isn't

This document specifies the CSDL and only the CSDL. It does not have an opinion about how CSDL should be generated from subgraphs. A suggestion is provided in [Appendix: Basic Composition Algorithm](#appendix-suggested-composition-algorithm), but conforming implementations may choose approach they like.

## Example: Let's go to the moon

*This section is non-normative.*

Throughout this document, we'll refer to this example. We are composing two schemasâ€”a `rockets` schema which serves data about rockets, and an `astronauts` service which services queries regarding the people flying on them.

### Rockets

<div class='not-csdl'>

```graphql
# Rockets Service
type Query {
  rockets: [Rocket]!
}

type Rocket @key(fields: "id"){
  id: String! 
  name: String!
	captain: Astronaut @provides(fields: "tripId")
}

extend type Astronaut @key(fields: "id"){
  id: String! @external
	tripId: String! @external
  rocket: Rocket!
}
```

</div>

### Astronauts

<div class='not-csdl'>

```graphql
# Astronauts Service
type Query {
  astronauts: [Astronaut]!
}

type Astronaut @key(fields: "id"){
  id: String! 
  name: String!
  tripId: String!
}

extend type Rocket @key(fields: "id"){
  id: String! @external
  astronaut: Astronaut!
}
```

</div>

### CSDL: Rockets & Astronauts

This example is non-normative, and represents just one possible way to compose [rockets](#rockets) and [astronauts](#astronauts) into CSDL.

```graphql
schema
  @graph(name: "rockets", url: "https://rockets.api.com")
  @graph(name: "astronauts", url: "https://astronauts.api.com")
  @csdl(version: "^1") {
  query: Query
}

type Query {
  rockets: [Rocket]! @resolve(graph: "rockets")
  astronauts: [Astronaut]! @resolve(graph: "astronauts")
}

type Astronaut 
	@key(fields: "{ id }", graph: "astronauts")
	@key(fields: "{ id }", graph: "rockets")
	@owner(graph: "astronauts")
{
  id: String!
  name: String!
	tripId: String!
  rocket: Rocket! @resolve(graph: "rockets")
}

type Rocket 
	@key(fields: "{ id }", graph: "rockets")
	@key(fields: "{ id }", graph: "astronauts")
	@owner(graph: "rockets")
{
  id: String!
  name: String!
  astronaut: Astronaut! @resolve(graph: "astronauts")
	captain: Astronaut @provides(fields: "{ tripId }")
}
```

The meaning of these directives is explored the [Directives](#directives) section.

## Composition Pipeline Roles

TK. better title? diagram. better words.

- **Producer** the bit that generates CSDL. spec will place requirements on composers.
- **Consumer** the bit that consumes CSDL. spec will place requirements on consumers.
- **Composer** a kind of producer which composes subgraph schemas into CSDL. (no requirements on consumers, diagrammed for clarity.)
- **Subgraphs** subgraphs which are composed by the composer (no requirements on subgraphs, diagrammed for clarity.)
- **Router** a kind of consumer which serves CSDL as a graphql endpoint. no requirements on routers, these are described in the federation spec.

## Directives
### `@key`
`directive @key(fields: String!, graph: String!) on OBJECT`

The first piece we need is already there. We need to know what keys an entity has. Secondly, we need to know what services define those keys. The `fields` argument is just a bracketed version of exactly what the service implementers write. The `graph` argument, is which graph a key is defined on. There may be any number of keys defined on the owning service (in the example below, the `astronauts` service) but the implementing services may only define one key. In our examples above, `Rocket` and `Astronaut` actually both have two `@key`s in the generated CSDL. One for each service.

```graphql
type Astronaut 
  @key(fields: "{ id }", graph: "astronauts") 
  @key(fields: "{ id }", graph: "rockets")
{ ... }
```

**One important detail** to notice here is that the `fields` value in CSDL is bracketed, like a selection set would be in GraphQL, although they're not in the original SDL that service implementers would write, like we did above. This is mostly a detail to help with parsing. Since this file is meant to be machine-readable by graphql parsers in many languages, using a bracketed selection set for `fields` is more friendly since, in many cases, it saves the work of concatenating brackets to the value for parsing a valid selection set.

### `@requires` and `@provides`

`directive @provides(fields: String!) on FIELD_DEFINITION`

`directive @requires(fields: String!) on FIELD_DEFINITION`

TK: Break this apart maybe?

`@requires` and `@provides` work almost exactly as they do when defining a federated schema, and aren't actually a feature of CSDL itself. `@requires` is a selection describing which fields a particular field needs in order to resolve itself, and `@provides` describes which fields a service can resolve, even if it doesn't own that type. For more information on how [requires](https://www.apollographql.com/docs/apollo-server/federation/entities/#extending-an-entity-with-computed-fields-advanced) and [provides](https://www.apollographql.com/docs/apollo-server/federation/entities/#resolving-another-services-field-advanced) work, check out the [federation docs](https://www.apollographql.com/docs/apollo-server/federation/entities).

The one difference to note is similar to the `@key` directive above: their `fields` arguments are bracketed.

```graphql
type Rocket 
  @key(fields: "{ id }", graph: "rockets")
  @key(fields: "{ id }", graph: "astronauts") 
{
	id: String! 
  name: String!
	astronaut: Astronaut!
  captain: Astronaut @provides(fields: "{ tripId }")
}
```

### `@owner`

`directive @owner(graph: String!) on OBJECT`

Just like any other GraphQL service, federated services can define any types they would like or need. When a service defines a type that hasn't been defined before (that is, it's not extending a type), then that service is referred to as the `owner` of that type. Type ownership is important, because services have the ability to extend types defined by other services in the graph, and those extenders can require additional fields from the owner to help them resolve their extensions. In our example, the `Astronaut` type is defined by the astronauts service, and the `Rocket`  type by the rockets service. We can represent that in CSDL like so:

```graphql
type Astronaut 
	@key(fields: "{ id }", graph: "astronauts")
	@key(fields: "{ id }", graph: "rockets")
	@owner(graph: "astronauts")
{
  id: String!
  name: String!
  rocket: Rocket!
	tripId: String!
}

type Rocket 
	@key(fields: "{ id }", graph: "rockets")
	@key(fields: "{ id }", graph: "astronauts")
	@owner(graph: "rockets")
{
  id: String!
  name: String!
	astronaut: Astronaut!
  captain: Astronaut @provides(fields: "{ tripId }")
}
```

**Not all types** get an `@owner` defined in CSDL:
- Value types are shared amongst all services and don't receive an owner.
- Types which are defined and used only in one service don't receive an owner.
- Root types (`Query` and `Mutation`) must not have owners.


### `@resolve`

`directive @resolve(graph: String!) on FIELD_DEFINITION`

Once we know about owning services for types, we have to represent what service is responsible for resolving fields that are extended by other services. We do this with the `resolve` directive. For the `rocket` field on our `Astronaut` type and the `astronaut` field on our `Rocket` type, that would look like this:

```graphql
type Astronaut 
	@key(fields: "{ id }", graph: "astronauts")
	@key(fields: "{ id }", graph: "rockets")
	@owner(graph: "astronauts")
{
  id: String!
  name: String!
	tripId: String!
  rocket: Rocket! @resolve(graph: "rockets")
}

type Rocket 
	@key(fields: "{ id }", graph: "rockets")
	@key(fields: "{ id }", graph: "astronauts")
	@owner(graph: "rockets")
{
  id: String!
  name: String!
  astronaut: Astronaut! @resolve(graph: "astronauts")
	captain: Astronaut @provides(fields: "{ tripId }")
}
```

In addition to these fields, all fields on the root `Query` or `Mutation` types also need a `@resolve` directive, since those types aren't owned by any service

```graphql
type Query {
  rockets: [Rocket]! @resolve(graph: "rockets")
  astronauts: [Astronaut]! @resolve(graph: "astronauts")
}
```

### `@csdl` and `@graph`

TK: break these apart

`directive **@csdl**(version: String!) on SCHEMA`

`directive **@graph**(name: String!, url: String!) on SCHEMA`

These two directives describe the state of the composed graph. These two directives, rather than being defined on a field or a type, are defined on the `schema` itself. `@csdl` is a versioning tool to describe the version of the CSDL format itself as a semver string. `@graph` is used multiple times to define the name and url of each of the implementing services.

```graphql
schema
  @graph(name: "rockets", url: "https://rockets.api.com")
  @graph(name: "astronauts", url: "https://astronauts.api.com")
  @csdl(version: "^1") {
  query: Query
}
```

## Divergence from GraphQL SDL

CSDL is a subset of GraphQL. In particular, CSDL differs from GraphQL SDL in the following ways:
- **Extensions are forbidden.** You cannot `extend type` or `extend interface` within a CSDL document.
- **`schema @csdl` is mandatory** Conforming CSDL documents must have a `schema` and it must have a `@csdl` directive specifying, at a minimum, the semver for the CSDL spec in use


## Validations

### validate no extensions
### validate csdl version
### validate all fields resolvable


## Glossary
#### Endpoint
An endpoint is a running server which can resolve GraphQL queries against a schema. In this version of the spec, endpoints must be URLs, typically http/https URLs.
#### Graph Router
A GraphQL server which can resolve queries against a CSDL schema. Graph routers differ from standard GraphQL endpoints in that they are not expected to process data or communicate with (non-GraphQL) backend services on their own. Instead, graph routers receive GraphQL requests and service them by performing additional GraphQL requests.
#### Subgraph
Subgraphs are the GraphQL schemas which were composed to form the CSDL. A subgraph has:
  - a name, which must be unique within the CSDL
  - an [endpoint](#endpoint)

## Appendix: Suggested Composition Algorithm

TK